#!/usr/bin/env python3

"""
A passphrase and passcode generator using MVC architecture, which is
structured in three main classes of Model, View, and Controller;
modified from posts by Brian Oakley at
https://stackoverflow.com/questions/32864610/
"""
# 'Copyright (C) 2021- 2022 C.S. Echt, under GNU General Public License'

# Standard library imports
import argparse
import glob
import random
from math import log
from pathlib import Path
from string import digits, punctuation, ascii_letters, ascii_uppercase

# Local application imports
import pass_utils
from pass_utils import (platform_check as chk,
                        configurations as cfg,
                        path_check as path,
                        utils)

# Third party imports (tk may not be included with some Python installations).
try:
    import tkinter as tk
    import tkinter.font
    from tkinter import messagebox, ttk
    from tkinter.scrolledtext import ScrolledText
except (ImportError, ModuleNotFoundError) as error:
    print('Passphrase requires tkinter, which is included with some Python 3.7+'
          '\ndistributions, such as from Active State.'
          '\nInstall 3.7+ or re-install Python and include Tk/Tcl.'
          '\nDownloads available from python.org'
          '\nOn Linux-Ubuntu you may need: sudo apt install python3-tk'
          f'\nSee also: https://tkdocs.com/tutorial/install.html \n{error}')


class PassModeler:
    """
    Set up lists of words and characters, randomize subsets to construct
    pass-strings, then calculate their length and entropy for display.
    """

    def __init__(self, share):
        self.share = share

        self.share.word_files = {
            'System dictionary': path.SYSDICT_PATH,
            'EFF long wordlist': path.WORDDIR / 'eff_large_wordlist.txt',
            'US Constitution': path.WORDDIR / 'usconst_wordlist.txt',
            'Don Quijote': path.WORDDIR / 'don_quijote_wordlist.txt',
            'Frankenstein': path.WORDDIR / 'frankenstein_wordlist.txt',
            'Les Miserables': path.WORDDIR / 'les_miserables.txt',
            '此開卷第 Story of the Stone': path.WORDDIR / 'red_chamber_wordlist.txt'
        }

    def check_files(self) -> None:
        """
        Confirm whether required files are present, exit if not.
        Update wordlist options based on availability.
        """

        all_lists = list(self.share.word_files.keys())
        if chk.MY_OS in 'lin, dar':
            self.share.choose_wordlist['values'] = all_lists
        # Need to remove 'System dictionary' from Windows usage.
        elif chk.MY_OS == 'win':
            all_lists.remove('System dictionary')
            self.share.choose_wordlist['values'] = all_lists

        fnf_msg = ('\nHmmm. Cannot locate system dictionary\n'
                   'words nor any custom wordlist files\n'
                   '(*_wordlist.txt). Wordlist files should be\n'
                   'in a folder called "wordlists" included\n'
                   'with the repository downloaded from:\n'
                   f'{pass_utils.URL}\nWill exit program now...')

        wordfile_list = glob.glob(str(path.WORDDIR / '*_wordlist.txt'))
        # This covers platforms with and w/o system dictionary.
        if not Path.is_file(path.SYSDICT_PATH):
            if len(wordfile_list) == 0:
                print(fnf_msg)
                messagebox.showinfo(title='Files not found', detail=fnf_msg)
                utils.quit_gui(gui=True)

            if len(wordfile_list) > 0 and chk.MY_OS != 'win':
                notice = ('Hmmm. The system dictionary cannot be found.\n'
                          'Using only custom wordlists ...')
                # print(notice)
                messagebox.showinfo(title='File not found', detail=notice)
                # Need to remove 'System dictionary' as an option.
                all_lists = list(self.share.word_files.keys())
                all_lists.remove('System dictionary')
                self.share.choose_wordlist['values'] = all_lists

        elif Path.is_file(path.SYSDICT_PATH) and len(wordfile_list) == 0:
            notice = ('Oops! Optional wordlists are missing.\n'
                      'Wordlist files should be in a folder\n'
                      'called "wordlists" included with\n'
                      'the repository downloaded from:\n'
                      f'{pass_utils.URL}\n'
                      'Using system dictionary words...\n')
            self.share.choose_wordlist.config(state='disabled')
            # print(notice)
            messagebox.showinfo(title='File not found', detail=notice)
            self.share.choose_wordlist['values'] = ('System dictionary',)

        # Need to have default .get() in combobox be the 1st available wordlist.
        self.share.choose_wordlist.current(0)

    def get_words(self) -> None:
        """
        Populate lists with words to randomize in make_pass(); needs to
        run at start and each time a new wordlist is selected by user.
        """

        # Need to reset excluded characters and prior pass-strings when a new
        #   wordlist is selected.
        self.share.tkdata['pp_raw_h'].set(0)
        self.share.tkdata['pp_plus_h'].set(0)
        self.share.tkdata['pp_short_h'].set(0)
        self.share.tkdata['pp_raw_len'].set(0)
        self.share.tkdata['pp_plus_len'].set(0)
        self.share.tkdata['pp_short_len'].set(0)
        self.share.exclude_entry.delete(0, 'end')
        self.share.tkdata['excluded'].set('')
        cfg.string_data['all_unused'] = ''
        # Need to retain stub result only for startup, otherwise delete
        #   the results each time get_words() or share.getwords() is called.
        if self.share.tkdata['phrase_raw'].get() not in self.share.stubresult:
            self.share.tkdata['phrase_raw'].set('')
            self.share.tkdata['phrase_plus'].set('')
            self.share.tkdata['phrase_short'].set('')

        # The *_wordlist.txt files have only unique words, but...
        #   use set() and split() here to generalize for any text file.
        # Need read_text(encoding) so Windows can read all wordlist fonts.
        choice = self.share.choose_wordlist.get()
        wordfile = self.share.word_files[choice]
        # all_words is also needed in make_pass to handle no_caps <-> caps
        #   transitions.
        self.share.all_words = set(
            Path(wordfile).read_text(encoding='utf-8').split())

        # Need to remove words having the possessive form ('s) b/c they
        #   duplicate many nouns in an English system dictionary.
        #   isalpha() also removes hyphenated words; EFF large wordlist has 4.
        # NOTE that all wordfiles were constructed with parse_wordlist script from
        # https://github.com/csecht/make_wordlist, and so contain only words
        # of 3 or more characters.
        if self.share.tkdata['no_caps'].get():
            working_list = cfg.list_data['word_list'] = [
                _w for _w in self.share.all_words if _w.isalpha() and _w[0].islower()]
        else:
            working_list = cfg.list_data['word_list'] = [
                _w for _w in self.share.all_words if _w.isalpha()]

        cfg.list_data['short_list'] = [_w for _w in working_list if len(_w) < 7]

        # This is used for live updates in the main window for number of words
        #   in the selected wordlist.
        self.share.tkdata['available'].set(len(working_list))

    def make_pass(self) -> None:
        """
        Generate and set random pass-strings.
        Called through Controller from keybinding, menu, or button.
        Calls set_entropy() and config_results().
        """

        # Need to correct invalid user entries for number of words & characters.
        numwords = self.share.numwords_entry.get().strip()
        if numwords == '':
            self.share.numwords_entry.insert(0, '0')
        elif not numwords.isdigit():
            self.share.numwords_entry.delete(0, 'end')
            self.share.numwords_entry.insert(0, '0')
        numwords = int(self.share.numwords_entry.get())

        numchars = self.share.numchars_entry.get().strip()
        if numchars == '':
            self.share.numchars_entry.insert(0, '0')
        if not numchars.isdigit():
            self.share.numchars_entry.delete(0, 'end')
            self.share.numchars_entry.insert(0, '0')
        numchars = int(self.share.numchars_entry.get())

        # Do not accept entries with space between characters, and.
        #   need to reset to default values if user deletes the prior entry.
        excluded = self.share.exclude_entry.get().strip()
        if ' ' in excluded or len(excluded) == 0:
            self.reset()

        def remove_excluded():
            cfg.list_data['word_list'] = [
                _w for _w in cfg.list_data['word_list'] if excluded not in _w]
            cfg.list_data['short_list'] = [
                _w for _w in cfg.list_data['short_list'] if excluded not in _w]
            cfg.string_data['symbols'] = [
                _s for _s in cfg.string_data['symbols'] if excluded not in _s]
            cfg.string_data['digi'] = [
                _d for _d in cfg.string_data['digi'] if excluded not in _d]
            cfg.string_data['caps'] = [
                _uc for _uc in cfg.string_data['caps'] if excluded not in _uc]
            cfg.string_data['all_char'] = [
                _ch for _ch in cfg.string_data['all_char'] if excluded not in _ch]
            cfg.string_data['some_char'] = [
                _ch for _ch in cfg.string_data['some_char'] if excluded not in _ch]
            # Need to display # of currently available words in two places.
            #   'available' is used as param in PassController.explain() and
            #   the self.share.available_show Label in main window.
            self.share.tkdata['available'].set(len(cfg.list_data['word_list']))

        # Need to filter words and strings containing characters to be excluded.
        #   When switching Checkbox from no_caps to caps, need to restore the
        #   full 'word_list' so exclusions can be reapplied. This redefines
        #   'word_list' and 'short_list' from get_words().
        if len(excluded) > 0:
            if self.share.tkdata['no_caps'].get():
                working_list = cfg.list_data['word_list'] = [
                    _w for _w in cfg.list_data['word_list'] if _w[0].islower()]
                remove_excluded()
            else:
                working_list = cfg.list_data['word_list'] = [
                    _w for _w in self.share.all_words if _w.isalpha()]
                cfg.list_data['short_list'] = [_w for _w in working_list if len(_w) < 7]
                remove_excluded()

            # Display all unique currently excluded characters.
            if excluded not in cfg.string_data['all_unused'] and ' ' not in excluded:
                cfg.string_data['all_unused'] = cfg.string_data['all_unused'] + ' ' + excluded
                self.share.tkdata['excluded'].set(cfg.string_data['all_unused'])
        else:
            self.share.tkdata['available'].set(len(cfg.list_data['word_list']))

        # Build pass-strings.
        passphrase = ""
        shortphrase = ""
        passcode1 = ""
        passcode2 = ""
        addsymbol = ""
        addnum = ""
        addcaps = ""
        # If all char are excluded, then cannot generate pass-strings
        #   because raises "IndexError: Cannot choose from an empty sequence.";
        #   for example, cannot exclude all digits.
        try:
            passphrase = "".join(cfg.very_random.choice(cfg.list_data['word_list']) for
                                 _ in range(numwords))
            shortphrase = "".join(cfg.very_random.choice(cfg.list_data['short_list']) for
                                  _ in range(numwords))
            passcode1 = "".join(cfg.very_random.choice(cfg.string_data['all_char']) for
                                _ in range(numchars))
            passcode2 = "".join(cfg.very_random.choice(cfg.string_data['some_char']) for
                                _ in range(numchars))
            # Randomly select 1 of each symbol to append; length not user-specified.
            addsymbol = "".join(
                cfg.very_random.choice(cfg.string_data['symbols']) for _ in range(1))
            addnum = "".join(cfg.very_random.choice(cfg.string_data['digi']) for _ in range(1))
            addcaps = "".join(cfg.very_random.choice(cfg.string_data['caps']) for _ in range(1))
        except IndexError:
            messagebox.showerror(
                title='Exceeded exclusion limit',
                message='Uh oh!',
                detail='No characters of one of the required types are left to exclude.'
                       ' Try again with fewer exclusions. Time to exit...')
            utils.quit_gui(gui=True)

        # Build passphrase alternatives.
        phraseplus = passphrase + addsymbol + addnum + addcaps
        phraseshort = shortphrase + addsymbol + addnum + addcaps

        # Set all pass-strings for display in results frames.
        self.share.tkdata['phrase_raw'].set(passphrase)
        self.share.tkdata['pp_raw_len'].set(len(passphrase))
        self.share.tkdata['phrase_plus'].set(phraseplus)
        self.share.tkdata['pp_plus_len'].set(len(phraseplus))
        self.share.tkdata['phrase_short'].set(phraseshort)
        self.share.tkdata['pp_short_len'].set(len(phraseshort))
        self.share.tkdata['pc_any'].set(passcode1)
        self.share.tkdata['pc_any_len'].set(len(passcode1))
        self.share.tkdata['pc_some'].set(passcode2)
        self.share.tkdata['pc_some_len'].set(len(passcode2))

        # Finally, set H values for each pass-string and configure results.
        self.set_entropy(numwords, numchars)
        self.config_results()

    def set_entropy(self, numwords: int, numchars: int) -> None:
        """Calculate and set values for information entropy, H.

        :param numwords: User-defined number of passphrase words.
        :param numchars: User-defined number of passcode characters.
        """
        # https://en.wikipedia.org/wiki/Password_strength
        # For +3 characters, we use only 1 character each from each set of
        # symbols, numbers, caps, so only need P of selecting one element
        # from a set to obtain H, then sum all P.
        # https://en.wikipedia.org/wiki/Entropy_(information_theory)
        # Note that length of these string may reflect excluded characters.
        h_symbol = -log(1 / len(cfg.string_data['symbols']), 2)
        h_digit = -log(1 / len(cfg.string_data['digi']), 2)
        h_cap = -log(1 / len(cfg.string_data['caps']), 2)
        h_add3 = int(h_symbol + h_cap + h_digit)  # H ~= 11

        # Calculate information entropy, H = L * log N / log 2, where N is the
        #   number of possible characters or words and L is the number of characters
        #   or words in the pass-string. Log can be any base, but needs to be
        #   the same base in numerator and denominator.
        # Note that N is corrected for any excluded words from set_pstrings().
        # Need to display H as integer, not float.
        self.share.tkdata['pp_raw_h'].set(
            int(numwords * log(len(cfg.list_data['word_list'])) / log(2)))

        self.share.tkdata['pp_plus_h'].set(
            self.share.tkdata['pp_raw_h'].get() + h_add3)
        h_some = int(numwords * log(len(cfg.list_data['short_list'])) / log(2))
        self.share.tkdata['pp_short_h'].set(h_some + h_add3)
        self.share.tkdata['pc_any_h'].set(
            int(numchars * log(len(cfg.string_data['all_char'])) / log(2)))
        self.share.tkdata['pc_some_h'].set(
            int(numchars * log(len(cfg.string_data['some_char'])) / log(2)))

    def config_results(self) -> None:
        """
        Configure fonts and display widths in results frames to provide
        a more readable display of results. Called from make_pass().
        """
        # Change font colors of results from the initial self.passstub_fg.
        # pass_fg does not change after first call to set_pstrings().
        self.share.pp_raw_show.config(fg=self.share.pass_fg)
        self.share.pp_plus_show.config(fg=self.share.pass_fg)
        self.share.pp_short_show.config(fg=self.share.pass_fg)
        self.share.pc_any_show.config(fg=self.share.pass_fg)
        self.share.pc_some_show.config(fg=self.share.pass_fg)

        # Need to indicate when passphrases exceeds length of result field,
        #   then reset to default when pass-string length is shortened.
        # Use pp_plus_len, the likely longest passphrase, to trigger change.
        passphrase_len = self.share.tkdata['pp_plus_len'].get()

        # Need a special case for wider Chinese characters; 34 equivalent to 52
        #    Use 64% to generalize in case W changes.
        results_width = cfg.W
        if self.share.choose_wordlist.get() == '此開卷第 Story of the Stone' \
                and passphrase_len > cfg.W * 0.64:
            results_width = cfg.W * 0.64

        if passphrase_len > results_width:
            self.share.pp_raw_show.config(fg=self.share.long_fg)
            self.share.pp_plus_show.config(fg=self.share.long_fg)
            self.share.pp_short_show.config(fg=self.share.long_fg)
        elif passphrase_len <= results_width:
            self.share.pp_raw_show.config(fg=self.share.pass_fg)
            self.share.pp_plus_show.config(fg=self.share.pass_fg)
            self.share.pp_short_show.config(fg=self.share.pass_fg)

        # Need to show right-most of phrase in case length exceeds field width.
        self.share.pp_raw_show.xview_moveto(1)
        self.share.pp_plus_show.xview_moveto(1)
        self.share.pp_short_show.xview_moveto(1)

        # Need to also indicate long passcodes.
        passcode_len = int(self.share.numchars_entry.get())
        if passcode_len > cfg.W:
            self.share.pc_any_show.config(fg=self.share.long_fg)
            self.share.pc_some_show.config(fg=self.share.long_fg)
        elif passcode_len <= cfg.W:
            self.share.pc_any_show.config(fg=self.share.pass_fg)
            self.share.pc_some_show.config(fg=self.share.pass_fg)

    def reset(self):
        """
        Restore original word and character lists with default values.
        Removes exclusions and current passphrase and passcode results.
        Call get_words() to restore full word lists.
        """
        self.share.tkdata['pc_any'].set('')
        self.share.tkdata['pc_any_len'].set(0)
        self.share.tkdata['pc_any_h'].set(0)
        self.share.tkdata['pc_some'].set('')
        self.share.tkdata['pc_some_len'].set(0)
        self.share.tkdata['pc_some_h'].set(0)
        self.share.exclude_entry.delete(0, 'end')
        self.share.tkdata['excluded'].set('')

        cfg.string_data['all_unused'] = ''
        cfg.string_data['symbols'] = cfg.SYMBOLS
        cfg.string_data['digi'] = digits
        cfg.string_data['caps'] = ascii_uppercase
        cfg.string_data['all_char'] = ascii_letters + digits + punctuation
        cfg.string_data['some_char'] = ascii_letters + digits + cfg.SYMBOLS

        self.get_words()
        app.update_idletasks()


class PassViewer(tk.Frame):
    """
    Set up all GUI widgets and display results from Modeler in the main
    window.
    """

    def __init__(self, share):
        super().__init__()
        self.share = share
        # Note that self.master is an internal attribute and refers to the
        #   PassController() Tk top window. Outside of PassViewer(),
        #   use app. to refer to the CountController() Tk object.

        # Need to set up default fonts and sizes for all windows.
        # All control methods in PassController are named as oneword()
        #    and refer to a MVC Class method of same name in snake_case().
        self.share.setfonts()

        # Font colors used in main (app) window:
        self.master_fg = 'grey90'  # Used for row headers.
        self.master_bg = 'SkyBlue4'  # Also used for some labels.
        self.dataframe_bg = 'grey40'  # Also background for data labels.
        self.stubpass_fg = 'grey60'  # For initial pass-string stub.
        self.share.pass_fg = 'brown4'  # Pass-string font color.
        self.share.long_fg = 'blue'  # Long pass-string font color.
        self.pass_bg = 'khaki2'  # Background of pass-string results cells.

        self.share.stubresult = 'Result can be copied and pasted.'

        # All data variables that are passed(shared) between Modeler and Viewer.
        self.share.tkdata = {
            'available': tk.IntVar(),
            'pp_raw_h': tk.IntVar(value=0),
            'pp_plus_h': tk.IntVar(value=0),
            'pp_short_h': tk.IntVar(value=0),
            'pp_raw_len': tk.IntVar(value=0),
            'pp_plus_len': tk.IntVar(value=0),
            'pp_short_len': tk.IntVar(value=0),
            'phrase_raw': tk.StringVar(value=self.share.stubresult),
            'phrase_plus': tk.StringVar(value=self.share.stubresult),
            'phrase_short': tk.StringVar(value=self.share.stubresult),
            'pc_any_len': tk.IntVar(value=0),
            'pc_some_len': tk.IntVar(value=0),
            'pc_any_h': tk.IntVar(value=0),
            'pc_some_h': tk.IntVar(value=0),
            'pc_any': tk.StringVar(value=self.share.stubresult),
            'pc_some': tk.StringVar(value=self.share.stubresult),
            'no_caps': tk.BooleanVar(),
            'excluded': tk.StringVar()
        }

        # Passphrase section %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        #  Generally sorted by row order.
        self.share.choose_wordlist = ttk.Combobox(state='readonly', width=24)
        self.share.choose_wordlist.bind('<<ComboboxSelected>>', self.share.getwords)

        self.share.available_head = tk.Label(
            text='# available words:',
            fg=self.pass_bg, bg=self.master_bg)
        self.share.available_show = tk.Label(
            textvariable=self.share.tkdata['available'],
            fg=self.pass_bg, bg=self.master_bg)

        self.numwords_label = tk.Label(text='# words',
                                       fg=self.pass_bg, bg=self.master_bg)
        self.share.numwords_entry = tk.Entry(width=2)
        # Use 4 words as default passphrase length.
        self.share.numwords_entry.insert(0, '4')

        self.l_and_h_header = tk.Label(text=' H      L', width=10,
                                       fg=self.master_fg, bg=self.master_bg)
        self.pp_section_head = tk.Label(text='Passphrase wordlists',
                                        font=('default', 12),
                                        fg=self.pass_bg, bg=self.master_bg)
        # MacOS needs a larger font and altered spacing
        if chk.MY_OS == 'dar':
            self.pp_section_head.config(font=('default', 16))
            self.l_and_h_header.config(text='H       L')

        self.result_frame1 = tk.Frame(self.master, borderwidth=3, relief='sunken',
                                      background=self.dataframe_bg)
        self.result_frame2 = tk.Frame(self.master, borderwidth=3, relief='sunken',
                                      background=self.dataframe_bg)

        self.pp_raw_head = tk.Label(text="Any words from list",
                                    fg=self.master_fg, bg=self.master_bg)
        self.pp_plus_head = tk.Label(text="... plus 3 characters",
                                     fg=self.master_fg, bg=self.master_bg)
        self.pp_short_head = tk.Label(text="...words less than 7 letters",
                                      fg=self.master_fg, bg=self.master_bg)

        self.pp_raw_h_lbl = tk.Label(self.result_frame1, width=3,
                                     fg=self.master_fg, bg=self.dataframe_bg,
                                     textvariable=self.share.tkdata['pp_raw_h'])
        self.pp_plus_h_lbl = tk.Label(self.result_frame1, width=3,
                                      fg=self.master_fg, bg=self.dataframe_bg,
                                      textvariable=self.share.tkdata['pp_plus_h'])
        self.pp_short_h_lbl = tk.Label(self.result_frame1, width=3,
                                       fg=self.master_fg, bg=self.dataframe_bg,
                                       textvariable=self.share.tkdata['pp_short_h'])

        self.pp_raw_len_lbl = tk.Label(self.result_frame1, width=3,
                                       fg=self.master_fg, bg=self.dataframe_bg,
                                       textvariable=self.share.tkdata['pp_raw_len'])
        self.pp_plus_len_lbl = tk.Label(self.result_frame1, width=3,
                                        fg=self.master_fg, bg=self.dataframe_bg,
                                        textvariable=self.share.tkdata['pp_plus_len'])
        self.pp_short_len_lbl = tk.Label(self.result_frame1, width=3,
                                         fg=self.master_fg, bg=self.dataframe_bg,
                                         textvariable=self.share.tkdata['pp_short_len'])

        # Results are displayed as Entry() instead of Text() b/c
        # textvariable is easier to code than .insert(). Otherwise, identical.
        self.share.pp_raw_show = tk.Entry(self.result_frame1, width=cfg.W,
                                          fg=self.stubpass_fg, bg=self.pass_bg,
                                          textvariable=self.share.tkdata['phrase_raw'],
                                          font=self.share.result_font)
        self.share.pp_plus_show = tk.Entry(self.result_frame1, width=cfg.W,
                                           fg=self.stubpass_fg, bg=self.pass_bg,
                                           textvariable=self.share.tkdata['phrase_plus'],
                                           font=self.share.result_font)
        self.share.pp_short_show = tk.Entry(self.result_frame1, width=cfg.W,
                                            fg=self.stubpass_fg, bg=self.pass_bg,
                                            textvariable=self.share.tkdata['phrase_short'],
                                            font=self.share.result_font)
        # End passphrase section %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

        # Passcode section %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        self.pc_section_head = tk.Label(text='Passcodes', font=('default', 12),
                                        fg=self.pass_bg, bg=self.master_bg)

        self.numchars_label = tk.Label(text='# characters',
                                       fg=self.pass_bg, bg=self.master_bg)
        self.share.numchars_entry = tk.Entry(width=3)
        self.share.numchars_entry.insert(tk.INSERT, '0')

        self.l_and_h_header2 = tk.Label(text=' H      L', width=10,
                                        fg=self.master_fg, bg=self.master_bg)
        # MacOS needs a larger font and altered spacing
        if chk.MY_OS == 'dar':
            self.pc_section_head.config(font=('default', 16))
            self.l_and_h_header2.config(text='H       L')

        self.pc_any_head = tk.Label(text="Any characters",
                                    fg=self.master_fg, bg=self.master_bg)
        self.pc_some_head = tk.Label(text="More likely usable characters",
                                     fg=self.master_fg, bg=self.master_bg)

        self.pc_any_len_lbl = tk.Label(self.result_frame2, width=3,
                                       fg=self.master_fg, bg=self.dataframe_bg,
                                       textvariable=self.share.tkdata['pc_any_len'])
        self.pc_some_len_lbl = tk.Label(self.result_frame2, width=3,
                                        fg=self.master_fg, bg=self.dataframe_bg,
                                        textvariable=self.share.tkdata['pc_some_len'])

        self.pc_any_h_lbl = tk.Label(self.result_frame2, width=3,
                                     fg=self.master_fg, bg=self.dataframe_bg,
                                     textvariable=self.share.tkdata['pc_any_h'])
        self.pc_some_h_lbl = tk.Label(self.result_frame2, width=3,
                                      fg=self.master_fg, bg=self.dataframe_bg,
                                      textvariable=self.share.tkdata['pc_some_h'])

        self.share.pc_any_show = tk.Entry(self.result_frame2,
                                          textvariable=self.share.tkdata['pc_any'],
                                          width=cfg.W, font=self.share.result_font,
                                          fg=self.stubpass_fg, bg=self.pass_bg)
        self.share.pc_some_show = tk.Entry(self.result_frame2,
                                           textvariable=self.share.tkdata['pc_some'],
                                           width=cfg.W, font=self.share.result_font,
                                           fg=self.stubpass_fg, bg=self.pass_bg)
        # End passcode section %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

        # Begin exclude character section %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        self.exclude_head = tk.Label(text='Exclude character(s)',
                                     fg=self.pass_bg, bg=self.master_bg)
        self.share.exclude_entry = tk.Entry(width=2)
        self.excluded_head = tk.Label(text='Currently excluded:',
                                      fg=self.master_fg, bg=self.master_bg)
        self.excluded_show = tk.Label(textvariable=self.share.tkdata['excluded'],
                                      fg='orange', bg=self.master_bg)

        self.no_caps_head = tk.Label(text='No capitalized words',
                                     fg=self.pass_bg, bg=self.master_bg)
        self.no_caps = tk.Checkbutton(variable=self.share.tkdata['no_caps'],
                                      bg=self.master_bg)

        # End exclude character section %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

        self.share.compliment_txt = tk.Label(relief='flat', border=0,
                                             fg='orange', bg=self.master_bg)

        # There are problems of tk.Button text showing up on MacOS, so use ttk.
        # Explicit styles are needed for buttons to show properly on MacOS.
        #  ... even then, background and pressed colors won't be recognized.
        self.generate_btn = ttk.Button()
        self.exclude_info_b = ttk.Button()
        self.reset_button = ttk.Button()
        self.quit_button = ttk.Button()

        self.config_master()
        self.config_buttons()
        self.grid_all()
        self.share.checkfiles()
        self.share.getwords()

    def config_master(self) -> None:
        """Set up main window configuration, keybindings, & menus.
        """

        self.config(bg=self.master_bg)

        if chk.MY_OS == 'dar':
            ttk.Style().theme_use('alt')

        # Need fields to stretch with window drag size and for the master
        #   frame to properly fill the app window.
        self.master.columnconfigure(3, weight=1)
        for _row in range(10):
            self.master.rowconfigure(_row, weight=1)
        self.result_frame1.columnconfigure(3, weight=1)
        self.result_frame2.columnconfigure(3, weight=1)
        self.result_frame1.rowconfigure(2, weight=1)
        self.result_frame1.rowconfigure(3, weight=1)
        self.result_frame1.rowconfigure(4, weight=1)
        self.result_frame2.rowconfigure(7, weight=1)
        self.result_frame2.rowconfigure(8, weight=1)

        # Set up universal and OS-specific keybindings and menus
        self.master.bind_all('<Escape>', utils.quit_gui)
        self.master.bind('<Return>', self.share.makepass)
        self.master.bind('<KP_Enter>', self.share.makepass)

        cmdkey = ''
        if chk.MY_OS in 'lin, win':
            cmdkey = 'Control'
        elif chk.MY_OS == 'dar':
            cmdkey = 'Command'
        self.master.bind_all(f'<{f"{cmdkey}"}-equal>', self.share.growfont)
        self.master.bind_all(f'<{f"{cmdkey}"}-minus>', self.share.shrinkfont)
        self.master.bind(f'<{f"{cmdkey}"}-q>', utils.quit_gui)
        self.master.bind(f'<{f"{cmdkey}"}-g>', self.share.makepass)
        self.master.bind(f'<{f"{cmdkey}"}-o>', self.share.scratchpad)
        self.master.bind(f'<{f"{cmdkey}"}-r>', self.share.reset)
        self.master.bind('<Shift-Control-C>', self.share.complimentme)

        # Need to specify Ctrl-A for Linux b/c in tkinter that key is
        #   bound to <<LineStart>>, not <<SelectAll>>, for some reason?
        if chk.MY_OS in 'lin':
            def select_all():
                app.focus_get().event_generate('<<SelectAll>>')

            self.master.bind_all('<Control-a>', lambda _: select_all())

        # Need to specify OS-specific right-click mouse button only in
        #    passstring fields of master window
        right_button = ''
        if chk.MY_OS in 'lin, win':
            right_button = '<Button-3>'
        elif chk.MY_OS == 'dar':
            right_button = '<Button-2>'
        self.share.pp_raw_show.bind(f'{right_button}', utils.click_cmds)
        self.share.pp_plus_show.bind(f'{right_button}', utils.click_cmds)
        self.share.pp_short_show.bind(f'{right_button}', utils.click_cmds)
        self.share.pc_any_show.bind(f'{right_button}', utils.click_cmds)
        self.share.pc_some_show.bind(f'{right_button}', utils.click_cmds)

        # Create menu instance and add pull-down menus
        menubar = tk.Menu(self.master)
        self.master.config(menu=menubar)

        os_accelerator = ''
        if chk.MY_OS in 'lin, win':
            os_accelerator = 'Ctrl'
        elif chk.MY_OS == 'dar':
            os_accelerator = 'Command'
        file = tk.Menu(self.master, tearoff=0)
        menubar.add_cascade(label='Passphrase', menu=file)
        file.add_command(label='Generate', command=self.share.makepass,
                         accelerator=f'{os_accelerator}+G')
        file.add_command(label='Reset', command=self.share.reset,
                         accelerator=f'{os_accelerator}+R')
        file.add_command(label='Open a scratch pad', command=self.share.scratchpad,
                         accelerator=f'{os_accelerator}+O')
        file.add(tk.SEPARATOR)
        file.add_command(label='Quit', command=lambda: utils.quit_gui(gui=True),
                         # MacOS doesn't recognize 'Command+Q' as an accelerator
                         #   b/c can't override that system's native Command+Q,
                         accelerator=f'{os_accelerator}+Q')

        edit = tk.Menu(self.master, tearoff=0)
        menubar.add_cascade(label='Edit', menu=edit)
        edit.add_command(label='Select all',
                         command=lambda: app.focus_get().event_generate('<<SelectAll>>'),
                         accelerator=f'{os_accelerator}+A')
        edit.add_command(label='Copy',
                         command=lambda: app.focus_get().event_generate('<<Copy>>'),
                         accelerator=f'{os_accelerator}+C')
        edit.add_command(label='Paste',
                         command=lambda: app.focus_get().event_generate('<<Paste>>'),
                         accelerator=f'{os_accelerator}+V')
        edit.add_command(label='Cut',
                         command=lambda: app.focus_get().event_generate('<<Cut>>'),
                         accelerator=f'{os_accelerator}+X')

        view = tk.Menu(self.master, tearoff=0)
        fontsize = tk.Menu(self.master, tearoff=0)
        menubar.add_cascade(label='View', menu=view)
        view.add_command(label='Font color changes?',
                         command=self.share.fontcolor)
        view.add_cascade(label='Font size...', menu=fontsize)
        # MacOS substitutes in appropriate key symbols for accelerators;
        #   Linux and Windows just use the literal strings.
        if chk.MY_OS in 'lin, win':
            fontsize.add_command(label='Bigger font',
                                 command=self.share.growfont,
                                 accelerator=f'{os_accelerator}+=(plus)')
            fontsize.add_command(label='Smaller font',
                                 command=self.share.shrinkfont,
                                 accelerator=f'{os_accelerator}+-(minus)')
        elif chk.MY_OS == 'dar':
            fontsize.add_command(label='Bigger font',
                                 command=self.share.growfont,
                                 accelerator=f'{os_accelerator}+=')
            fontsize.add_command(label='Smaller font',
                                 command=self.share.shrinkfont,
                                 accelerator=f'{os_accelerator}+-')
        fontsize.add_command(label='Default size',
                             command=self.share.defaultfontsize)

        help_menu = tk.Menu(self.master, tearoff=0)
        tips = tk.Menu(self.master, tearoff=0)
        menubar.add_cascade(label='Help', menu=help_menu)
        help_menu.add_cascade(label='Tips...', menu=tips)
        tips.add_command(label='Mouse right-click does stuff!')
        tips.add_command(label='   ...So do common keyboard commands.')
        tips.add_command(label='Return/Enter key also Generates.')
        tips.add_command(label='Menu Passphrase>Open.. opens a scratch pad.')
        tips.add_command(label='Very long results may be in blue font.')
        tips.add_command(label='Esc key exits program from any window.')
        help_menu.add_command(label="What's going on here?",
                              command=self.share.explain)
        help_menu.add_command(label='About',
                              command=self.share.about)
        # Need Ctrl+Shift+C for all OS b/c Command-Shift-C is a MacOS default for color palette.
        help_menu.add_command(label="I need a compliment",
                              command=self.share.complimentme,
                              accelerator='Ctrl+Shift+C')

    def config_buttons(self) -> None:
        """Set up all buttons used in master window.
        """
        # # There are problems of tk.Button text showing up on MacOS, so use ttk.
        # # Explicit styles are needed for buttons to show properly on MacOS.
        # #  ... even then, background and pressed colors won't be recognized.
        # self.generate_btn = ttk.Button()
        # self.exclude_info_b = ttk.Button()
        # self.reset_button = ttk.Button()
        # self.quit_button = ttk.Button()

        style = ttk.Style()
        style.map("My.TButton",
                  foreground=[('active', self.share.pass_fg)],
                  background=[('pressed', self.dataframe_bg),
                              ('active', self.pass_bg)])
        self.generate_btn.configure(style="My.TButton", text='Generate!',
                                    command=self.share.makepass)
        self.generate_btn.focus()
        self.reset_button.configure(style="My.TButton", text='Reset',
                                    width=0,
                                    command=self.share.reset)
        self.exclude_info_b.configure(style="My.TButton", text="?",
                                      width=0,
                                      command=self.share.excludemsg)
        self.quit_button.configure(style="My.TButton", text='Quit',
                                   width=0,
                                   command=lambda: utils.quit_gui(gui=True))

    def grid_all(self) -> None:
        """Grid all tkinter widgets.
        """
        # This self.grid fills out the inherited tk.Frame, padding gives border.
        # Padding depends on app.minsize/maxsize in PassController
        # Frame background color, self.master_bg, is set in config_master().
        self.grid(column=0, row=0,
                  rowspan=12, columnspan=4,
                  padx=3, pady=3, sticky=tk.NSEW)

        # %%%%%%%%%%%%%%%%%%%%%%%% sorted by row number %%%%%%%%%%%%%%%%%%%%%%%
        # Passphrase widgets %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        self.pp_section_head.grid(column=0, row=0, pady=(10, 5),
                                  padx=(10, 5), sticky=tk.W)
        self.share.choose_wordlist.grid(column=1, row=0, pady=(10, 5), padx=5,
                                        columnspan=2, sticky=tk.W)
        self.share.available_head.grid(column=3, row=0, pady=(10, 0),
                                       padx=(5, 0), sticky=tk.W)
        # Need separate Label spacing for each OS:
        if chk.MY_OS == 'lin':
            self.share.available_show.grid(column=3, row=0, pady=(10, 0),
                                           padx=(130, 0), sticky=tk.W)
        elif chk.MY_OS == 'win':
            self.share.available_show.grid(column=3, row=0, pady=(10, 0),
                                           padx=(117, 0), sticky=tk.W)
        elif chk.MY_OS == 'dar':
            self.share.available_show.grid(column=3, row=0, pady=(10, 0),
                                           padx=(124, 0), sticky=tk.W)

        self.numwords_label.grid(column=0, row=1, padx=(10, 5), sticky=tk.W)
        self.share.numwords_entry.grid(
            column=0, row=1, padx=(10, 100), sticky=tk.E)
        self.l_and_h_header.grid(column=1, row=1, padx=0, sticky=tk.W)

        self.result_frame1.grid(column=1, row=2, padx=(5, 10),
                                columnspan=3, rowspan=3, sticky=tk.NSEW)
        # Results' _show will maintain equal widths with sticky=tk.EW.
        self.pp_raw_head.grid(column=0, row=2, pady=(6, 0), padx=(10, 0),
                              sticky=tk.E)
        self.pp_raw_h_lbl.grid(column=1, row=2, pady=(5, 3), padx=(5, 0))
        self.pp_raw_len_lbl.grid(column=2, row=2, pady=(5, 3), padx=(5, 0))
        self.share.pp_raw_show.grid(column=3, row=2, pady=(5, 3), padx=5,
                                    sticky=tk.EW)

        self.pp_plus_head.grid(column=0, row=3, pady=(3, 0), padx=(10, 0),
                               sticky=tk.E)
        self.pp_plus_h_lbl.grid(column=1, row=3, pady=(5, 3), padx=(5, 0))
        self.pp_plus_len_lbl.grid(column=2, row=3, pady=(5, 3), padx=(5, 0))
        self.share.pp_plus_show.grid(column=3, row=3, pady=(5, 3), padx=5,
                                     sticky=tk.EW)

        self.pp_short_head.grid(column=0, row=4, pady=(3, 6), padx=(10, 0),
                                sticky=tk.E)
        self.pp_short_h_lbl.grid(column=1, row=4, pady=3, padx=(5, 0))
        self.pp_short_len_lbl.grid(column=2, row=4, pady=3, padx=(5, 0))
        self.share.pp_short_show.grid(column=3, row=4, pady=6, padx=5,
                                      sticky=tk.EW)

        # Need to pad and span to center the button between two results frames.
        #   ...with different x padding to keep it aligned in different platforms.
        self.generate_btn.grid(column=3, row=5, rowspan=2, pady=(10, 5),
                               sticky=tk.W)
        if chk.MY_OS == 'lin':
            self.generate_btn.grid(padx=(40, 0))
        elif chk.MY_OS == 'win':
            self.generate_btn.grid(padx=(30, 0))
        elif chk.MY_OS == 'dar':
            self.generate_btn.grid(padx=(0, 0))

        # Passcode widgets %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        self.pc_section_head.grid(column=0, row=5, pady=(12, 6), padx=(10, 5),
                                  sticky=tk.W)

        self.numchars_label.grid(column=0, row=6, pady=0, padx=(10, 5),
                                 sticky=tk.W)
        self.share.numchars_entry.grid(
            column=0, row=6, pady=0, padx=(0, 65),
            sticky=tk.E)
        self.l_and_h_header2.grid(column=1, row=6, pady=0, padx=0,
                                  sticky=tk.W)

        self.result_frame2.grid(column=1, row=7, padx=(5, 10),
                                columnspan=3, rowspan=2, sticky=tk.NSEW)
        self.pc_any_head.grid(column=0, row=7, pady=(6, 0), padx=(10, 0),
                              sticky=tk.E)
        self.pc_any_h_lbl.grid(column=1, row=7, pady=(6, 3), padx=(5, 0))
        self.pc_any_len_lbl.grid(column=2, row=7, pady=(6, 3), padx=(5, 0))
        self.share.pc_any_show.grid(column=3, row=7, pady=(6, 3), padx=5,
                                    columnspan=2, sticky=tk.EW)

        self.pc_some_head.grid(column=0, row=8, pady=(0, 6), padx=(10, 0),
                               sticky=tk.E)
        self.pc_some_h_lbl.grid(column=1, row=8, pady=3, padx=(5, 0))
        self.pc_some_len_lbl.grid(column=2, row=8, pady=3, padx=(5, 0))
        self.share.pc_some_show.grid(column=3, row=8, pady=6, padx=5,
                                     columnspan=2, sticky=tk.EW)

        # Excluded character widgets %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        self.no_caps_head.grid(column=0, row=9, pady=(15, 0), padx=(17, 0),
                               sticky=tk.W)
        self.no_caps.grid(column=0, row=9, pady=(15, 0), padx=(0, 13),
                          sticky=tk.E)

        self.exclude_head.grid(column=0, row=10, pady=(5, 0), padx=(17, 0),
                               sticky=tk.W)
        self.share.exclude_entry.grid(column=0, row=10, pady=(5, 5), padx=(0, 15),
                                      sticky=tk.E)
        self.exclude_info_b.grid(column=1, row=10, pady=(5, 5), padx=(10, 0),
                                 sticky=tk.W)

        self.excluded_head.grid(column=0, row=11, pady=(0, 8), padx=(5, 0),
                                sticky=tk.E)
        self.reset_button.grid(column=0, row=11, pady=(0, 15), padx=(20, 0),
                               sticky=tk.W)
        self.excluded_show.grid(column=1, row=11, pady=(0, 8), sticky=tk.W)

        self.quit_button.grid(column=3, row=11, pady=(0, 15), padx=(0, 15),
                              sticky=tk.E)

        self.share.compliment_txt.grid(row=11, column=2, columnspan=2,
                                       pady=(0, 15), padx=5, sticky=tk.W)

        # Need to adjust padding for MacOS b/c of different font spacing.
        if chk.MY_OS == 'dar':
            self.exclude_head.grid(padx=(13, 0))
            self.reset_button.grid(columnspan=2, padx=(20, 0))
            self.excluded_head.grid(columnspan=2, padx=(95, 0), sticky=tk.W)
            self.excluded_show.grid(column=0, columnspan=2, padx=(223, 0))


class PassController(tk.Tk):
    """
    The Controller through which other MVC Classes can interact.
    """

    def __init__(self):
        super().__init__()

        # Need to fix window size to prevent an annoying window redraw each time
        #   font size changes the width of the result Entry() widgets and Frame().
        # Pixels here are set to fit a 52 character width Entry() and are
        #   OS-specific. (Constant W = 52 is arbitrary, but I like it.)
        if chk.MY_OS == 'lin':
            # self.minsize(830, 430)  # <for default font size=12, W=52
            # self.maxsize(830, 430)
            self.minsize(780, 430)  # <for default font size=11, W=52
            self.maxsize(780, 430)
        elif chk.MY_OS == 'win':
            self.minsize(702, 430)
            self.maxsize(702, 430)
        elif chk.MY_OS == 'dar':
            # self.minsize(745, 430)
            self.maxsize(745, 403)

        self.winfo_toplevel()
        PassViewer(share=self)

    def setfonts(self):
        """
        Is called from the Viewer __init__, which should be the only
        call to set_fonts(). Established default font styles and sizes.
        """
        PassFonts(share=self).set_fonts()

    # pylint: disable=unused-argument
    def growfont(self, keybind=None):
        """Is called from keybinding or View menu.

        :param keybind: Needed for keybindings
        """
        PassFonts(share=self).grow_font()

    # pylint: disable=unused-argument
    def shrinkfont(self, keybind=None):
        """Is called from keybinding or View menu.

        :param keybind: Needed for keybindings
        """
        PassFonts(share=self).shrink_font()

    def defaultfontsize(self):
        """
        Called from config_master() menu to reset font sizes to default.
        """
        PassFonts(share=self).default_font_size()

    def checkfiles(self):
        """
        Is called from the Viewer __init__, which should be the only
        call to check_files(). Exits if needed files not found,
        otherwise populates choose_wordlist Combobox.
        """
        PassModeler(share=self).check_files()

    # pylint: disable=unused-argument
    def getwords(self, *args):
        """
        Is called from the Viewer __init__ and Combobox binding.
        Populate lists with words to randomize in make_pass().

        :param args: Needed for call from Combobox virtual event binding.
        """
        PassModeler(share=self).get_words()

    # pylint: disable=unused-argument
    def makepass(self, keybind=None) -> None:
        """Is called via "Generate" key, button, menu.
        make_pass() creates random pass-strings, which then
        calls set_entropy() and config_results().

        :param keybind: Needed for call from keybinding.
        """
        PassModeler(share=self).make_pass()

    # pylint: disable=unused-argument
    def scratchpad(self, keybind=None):
        """Is called from the Viewer Passphrase menu or key binding.

        :param keybind: Needed for keybindings
        """
        PassFyi(share=self).scratch_pad()

    def explain(self):
        """
        Is called from Viewer Help menu. Parameters are live data feeds
        to the pop-up window.
        """
        PassFyi(share=self).explain(self.choose_wordlist.get(),
                                    self.tkdata['available'].get())

    def fontcolor(self):
        """Is called from Viewer Help menu.
        """
        PassFyi(share=self).font_color()

    def about(self):
        """Is called from Viewer Help menu.
        """
        PassFyi(share=self).about()

    def excludemsg(self):
        """Is called from the Viewer "?" button in exclude section.
        """
        PassFyi(share=self).exclude_msg()

    # pylint: disable=unused-argument
    def reset(self, keybind=None) -> None:
        """
        Resets all results and exclusions. Called from key, button, menu.

        :param keybind: Needed for keybindings
        """
        PassModeler(share=self).reset()

    def complimentme(self, keybind=None) -> None:
        """Is called from Help menu. A silly diversion.

        :param keybind: Needed for keybinding
        """
        PassFyi(share=self).compliment_me()


class PassFyi:
    """
    Provide pop-up windows to provide usage information and offer help.
    """

    def __init__(self, share):
        self.share = share

    def scratch_pad(self) -> None:
        """
        A text window for user to temporarily save results.
        Is called from Passphrase menu or keybinding.
        """
        # Separator dashes from https://coolsymbol.com/line-symbols.html.
        instruction = (
            'Paste here passphrases or passcodes that you are thinking of'
            ' using. You can then compare them, test typing them out, etc.'
            ' and see whether any work for you.\nWindow can be dragged'
            ' larger if things do not fit.\nAnything you paste or edit here'
            ' is GONE when this window is closed, so save what you want to'
            ' keep somewhere else.\n'
            '────────────────────────────────────────\n\n'
        )

        scratchwin = tk.Toplevel()
        scratchwin.title('Scratch Pad')
        scratchwin.minsize(300, 250)
        scratchwin.focus_set()
        utils.toplevel_bindings(scratchwin)

        scratchtxt = tk.Text(scratchwin, width=75,
                             background='grey85', foreground='grey5',
                             relief='groove', borderwidth=4,
                             padx=10, pady=10, wrap=tk.WORD,
                             font=self.share.text_font)
        scratchtxt.insert(tk.INSERT, instruction)
        # Center all text in the window
        scratchtxt.tag_add('text1', 1.0, tk.END)
        scratchtxt.tag_configure('text1', justify='center')
        scratchtxt.pack(fill=tk.BOTH, side=tk.LEFT, expand=True)

    def explain(self, selection: str, wordcount: int) -> None:
        """Provide information about words used to create passphrases.

        :param selection: User selected wordlist name.
        :param wordcount: Length of full selected wordlist list.
        :return: An text window notice with current wordlist data.
        """

        explanation = (
            """A passphrase is a random string of words that can be more secure and
easier to remember than a passcode of random characters. For more
information on passphrases, see, for example, a discussion of word lists
and word selection at the Electronic Frontier Foundation (EFF):
https://www.eff.org/deeplinks/2016/07/new-wordlists-random-passphrases\n
On MacOS and Linux systems, the system dictionary wordlist is used by
default to provide words, though optional wordlists are available.
Windows users can use only the optional wordlists.\n
"""
            f'     From the current selected wordlist, {selection},\n'
            '     after subtracting words with excluded letters, if any,\n'
            f'     there are {wordcount} words available to construct passphrases.\n'
            """
Passphrases and passcodes (pass-strings) are made by clicking the
Generate! button, or pressing Enter, Return, or Ctrl-G, or selecting
from the Passphrase pull-down menu on the menu bar. The result you
want can be cut and pasted using standard keyboard commands, or
right-clicking, or using Edit from the menu bar.\n
There is an option to exclude any character or string of characters
from passphrase words and passcodes. Words with excluded letters are
not available to use. Multiple windows can remain open to compare
counts among different wordlists and exclusions.  (more........)\n
Optional wordfiles were derived from texts obtained from these sites:
      https://www.gutenberg.org
      https://www.archives.gov/founding-docs/constitution-transcript
      https://www.eff.org/files/2016/07/18/eff_large_wordlist.txt
Although the EFF list contains 7776 selected words, only 7772 are used
here because hyphenated words are excluded from all wordlists.\n
Words with less than 3 letters are not used in any wordlist.\n
All wordlists except EFF were made with parse_wordlist from the Project
https://github.com/csecht/make_wordlist\n
To accommodate some passcode requirements, a choice is provided that
adds three characters : 1 symbol, 1 number, and 1 upper case letter.
"""
            f'The symbols used are: {cfg.SYMBOLS}\n'
            """
In the results fields, L is the character length of each pass-string.
H, as used here, is for comparing relative pass-string strengths.
Higher is better; each increase of 1 doubles the relative strength.
H is actually the information entropy (Shannon entropy) value and is
equivalent to bits of entropy. For more information see:
      https://explainxkcd.com/wiki/index.php/936:_Password_Strength
      https://en.wikipedia.org/wiki/Password_strength
      https://en.wikipedia.org/wiki/Entropy_(information_theory)
"""
        )
        explainwin = tk.Toplevel()
        explainwin.title('A word about words and characters')
        explainwin.minsize(595, 200)
        explainwin.focus_set()
        utils.toplevel_bindings(explainwin)

        os_width = 0
        if chk.MY_OS in 'lin, win':
            os_width = 62
        elif chk.MY_OS == 'dar':
            os_width = 55

        explaintext = ScrolledText(explainwin, width=os_width, height=25,
                                   bg='dark slate grey', fg='grey95',
                                   relief='groove', borderwidth=8,
                                   padx=30, pady=30, wrap=tk.WORD,
                                   font=self.share.text_font)
        explaintext.insert(tk.INSERT, explanation)
        explaintext.pack(fill=tk.BOTH, side=tk.LEFT, expand=True)
        # If need to prevent all key actions:
        # explaintext.bind("<Key>", lambda _: "break")

    def font_color(self) -> None:
        """Explain why the pass-string font changes color.
        """
        why = (
            'Pass-string font will turn BLUE when it is longer than what\n'
            '    can fit into the result cell at the default font size.\n'
            'To see the entire result, you can:\n'
            '    decrease font size (right-click or menu View -> Font size...)\n'
            '    or copy & paste the result into the scratch pad\n'
            '    (menu Passphrase -> Open a scratch pad.)'
        )
        num_lines = why.count('\n')
        colorwin = tk.Toplevel()
        colorwin.title('Why does result change color?')
        colorwin.minsize(250, 150)
        colorwin.focus_set()
        utils.toplevel_bindings(colorwin)

        os_width = 0
        if chk.MY_OS in 'lin, win':
            os_width = 52
        elif chk.MY_OS == 'dar':
            os_width = 48

        colortext = tk.Text(colorwin, width=os_width, height=num_lines,
                            bg='grey40', fg='grey95',
                            relief='groove', borderwidth=8,
                            padx=20, pady=10, wrap=tk.WORD,
                            font=self.share.text_font)
        colortext.insert(tk.INSERT, why)
        colortext.pack(fill=tk.BOTH, side=tk.LEFT, expand=True)

    @staticmethod
    def about() -> None:
        """Basic information about the script; called from GUI Help menu.
        """
        num_lines = __doc__.count('\n') + 2
        aboutwin = tk.Toplevel()
        aboutwin.title('About Passphrase')
        aboutwin.minsize(400, 200)
        aboutwin.focus_set()
        utils.toplevel_bindings(aboutwin)

        abouttext = ScrolledText(aboutwin, width=74, height=num_lines + 8,
                                 bg=utils.random_bkg(), fg='grey95',
                                 relief='groove', borderwidth=8,
                                 padx=30, pady=10, wrap=tk.WORD,
                                 # No size change with TFF instead of self.share.text_font.
                                 font='TkFixedFont',
                                 )
        abouttext.insert(tk.INSERT,
                         f'{__doc__}\n'
                         f'{"Author:".ljust(13)}{pass_utils.__author__}\n'
                         f'{"Version:".ljust(13)}{pass_utils.__version__}\n'
                         f'{"Status:".ljust(13)}{pass_utils.__status__}\n'
                         f'{"URL:".ljust(13)}{pass_utils.URL}\n'
                         f'{pass_utils.__copyright__}'
                         f'{pass_utils.LICENSE}\n'
                         )
        abouttext.pack(fill=tk.BOTH, side=tk.LEFT, expand=True)

        # If need to prevent all key actions:
        # abouttext.bind("<Key>", lambda _: "break")

    def exclude_msg(self) -> None:
        """A pop-up describing how to use excluded characters.
        Called only from a Button.

        :return: A message text window.
        """
        msg = (
            """
Any character(s) you enter will not appear in passphrase
words or passcodes. Multiple characters are treated as a
unit. For example, "es" will exclude "trees", not "eye"
and  "says". To exclude everything having "e" and "s",
enter "e", click Generate!, then enter "s" and Generate!

The Reset button (or Ctrl+R) removes all exclusions. A
space entered between characters will also do a reset.
"""
        )
        excludewin = tk.Toplevel()
        excludewin.title('Exclude from what?')
        excludewin.minsize(300, 100)
        excludewin.focus_set()
        utils.toplevel_bindings(excludewin)

        os_width = 0
        if chk.MY_OS in 'lin, win':
            os_width = 48
        elif chk.MY_OS == 'dar':
            os_width = 42

        num_lines = msg.count('\n')
        excludetext = tk.Text(excludewin, width=os_width, height=num_lines + 1,
                              bg='grey40', fg='grey95',
                              relief='groove', borderwidth=8,
                              padx=20, pady=10, wrap=tk.WORD,
                              font=self.share.text_font)
        excludetext.insert(1.0, msg)
        excludetext.pack(fill=tk.BOTH, side=tk.LEFT, expand=True)
        # If need to prevent all key actions:
        # excludetext.bind("<Key>", lambda _: "break")

    def compliment_me(self) -> None:
        """A silly diversion; called from Help menu.

        :return: Transient label to make one smile.
        """
        compliments = [
            "Hey there good lookin'!", 'I wish we had met sooner.',
            'You are the smartest person I know.', 'I like your hair.',
            'You have such a nice smile.', 'Smart move!',
            'Blue is your color.', 'Good choice!',
            "That's very kind of you.", "Stop! You're making me blush.",
            'I just love what you did.', 'How witty you are!', 'Awesome!',
            'Your tastes are impeccable.', "You're incredible!",
            'You are so talented!', "I wish I'd thought of that.",
            'This is fun!', 'Get back to work.', 'Nice!', 'You saved me.',
            'You are an inspiration to us all.', "That's so funny!",
            'Show me how you do that.', "I've always looked up to you.",
            'You sound great!', 'You smell nice.', 'Great job!',
            'You are a role model.', 'I wish more people were like you.',
            'We appreciate what you did.', 'I hear people look up to you.',
            'You are a really good dancer.', 'What makes you so successful?',
            'When you speak, people listen.', 'You are a superb person.',
            'You rock!', 'You nailed it!', 'That was really well done.',
            'You are amazing!', 'We need more folks like you around here.',
            'Excuse me, are you a model?', 'What a lovely laugh you have.',
            "I'm jealous of your ability.", "You're the stuff of legends.",
            'This would not be possible without you.', 'Way to go! Yay!',
            'Did you make that? I love it!', 'You are the best!',
            'I like what you did.', 'Whoa. Have you been working out?',
            "We can't thank you enough.", 'No, really, you have done enough.',
            "That's a good look for you.", 'I could not have done it better.',
            "I can't think of anything to say. Sorry.", 'Congratulations!',
            "Well, THAT's impressive.", 'I hear that you are the one.',
            'You excel at everything.', 'Your voice is very soothing.',
            'Is it true what people say?', 'The word is, you got it!',
            'The Nobel Committee has been trying to reach you.',
            'The Academy is asking for your CV.', 'You look great!',
            'The President seeks your council.', 'Thank you so much!',
        ]
        praise = random.choice(compliments)
        self.share.compliment_txt.config(text=praise)

        def refresh():
            self.share.compliment_txt.config(text="")
            app.update_idletasks()

        self.share.compliment_txt.after(2222, refresh)


class PassFonts:
    """
    Change MVC font settings. Call with keybindings or menu commands.
    """

    # font.Font keywords are: family, font, size, weight, underline, overstrike.
    def __init__(self, share):
        self.share = share

        if chk.MY_OS == 'lin':
            self.sizemax = 16
            self.sizemin = 4
        elif chk.MY_OS == 'win':
            self.sizemax = 15
            self.sizemin = 6
        elif chk.MY_OS == 'dar':
            self.sizemax = 20
            self.sizemin = 9

    def set_fonts(self):
        """ Establish default cross-OS Tk fonts and sizes at start-up.
        """
        # Need to define as font.Font to configure().
        # Different OS need different size for best readability and to fit in
        #  in the passcode W=52 field.
        self.share.text_font = tk.font.Font(font='TkTextFont')
        self.share.result_font = tk.font.Font(font='TkFixedFont')

        # get font info from self.share.text_font.actual()
        if chk.MY_OS == 'lin':
            self.share.result_font.configure(size=11)
            self.share.default_txt_font = 10
            self.share.default_res_font = 11
        if chk.MY_OS == 'win':
            self.share.result_font.configure(size=10)
            self.share.default_txt_font = 10
            self.share.default_res_font = 10
        elif chk.MY_OS == 'dar':
            self.share.text_font.configure(size=14)
            self.share.result_font.configure(size=13)
            self.share.default_txt_font = 14
            self.share.default_res_font = 13

    def grow_font(self):
        """ Make the font size larger.
        """
        tsize = self.share.text_font['size']
        if tsize < self.sizemax:
            self.share.text_font.configure(size=tsize + 1)
        rsize = self.share.result_font['size']
        if rsize < self.sizemax:
            self.share.result_font.configure(size=rsize + 1)

    def shrink_font(self):
        """ Make the font size smaller.
        """
        tsize = self.share.text_font['size']
        if tsize > self.sizemin:
            self.share.text_font.configure(size=tsize - 1)
        rsize = self.share.result_font['size']
        if rsize > self.sizemin:
            self.share.result_font.configure(size=rsize - 1)

    def default_font_size(self):
        """ The default font size on startup. Used to reset to default.
        """
        self.share.text_font.config(size=self.share.default_txt_font)
        self.share.result_font.config(size=self.share.default_res_font)


def manage_args() -> None:
    """Allow handling of common command line arguments.
    """
    parser = argparse.ArgumentParser()
    parser.add_argument('--about',
                        help='Provides description, version, GNU license',
                        action='store_true',
                        default=False)
    args = parser.parse_args()

    if args.about:
        print(__doc__)
        print(f'{"Author:".ljust(13)}', pass_utils.__author__)
        print(f'{"Version:".ljust(13)}', pass_utils.__version__)
        print(f'{"Status:".ljust(13)}', pass_utils.__status__)
        print(f'{"URL:".ljust(13)}', pass_utils.URL)
        print(pass_utils.__copyright__)
        print(pass_utils.LICENSE)
        print()
        utils.quit_gui(gui=False)


if __name__ == "__main__":
    # System platform and version checks are run in tk_utils __init__.py
    #   Program exits if checks fail.

    manage_args()

    app = PassController()
    app.title("Passphrase Generator")

    img = tk.PhotoImage(file=path.valid_path_to('images/passphrase_icon512.png'))
    app.wm_iconphoto(True, img)

    app.clipboard_clear()

    try:
        app.mainloop()
    except KeyboardInterrupt:
        print('\n*** User quit the program ***\n')
    except Exception as unk:
        print(f'An error occurred: {unk}')
        print('Program exit with unexpected condition.')
        utils.quit_gui(gui=True)
