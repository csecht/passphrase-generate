#!/usr/bin/env python3

"""
Inspired by and based on code from @codehub.py via Instagram.
Not usable on Windows because of no way(?) to read the Dictionary.
"""
import os
import random
import re
from string import digits, punctuation, ascii_letters, ascii_uppercase
from pathlib import Path

try:
    import tkinter as tk
    # import tkinter.ttk as ttk
except (ImportError, ModuleNotFoundError) as error:
    print('GUI requires tkinter, which is included with Python 3.7 and higher')
    print('Install 3.7+ or re-install Python and include Tk/Tcl.')
    print(f'See also: https://tkdocs.com/tutorial/install.html \n{error}')

PROGRAM_VER = '0.1.0'
STUBRESULT = 'Result can be copied and pasted'
SYS_DICTIONARY = Path('/usr/share/dict/words').read_text()
EFF_DICTIONARY = Path('eff_large_wordlist.txt').read_text()
SYMBOLS = "~!@#$%^&*_-"


class Generator:
    """
    Makes a GUI window for user to specify length of passwords and passphrases.
    """
    def __init__(self, master):
        """Window layout and default values are set up here.
        """
        self.master = master
        self.master.bind("<Escape>", lambda q: quitgui())
        self.master.bind("<Control-q>", lambda q: quitgui())

        # main window background color, also used for some labels.
        self.master_bg = 'SkyBlue4'
        self.master_fg = 'LightCyan2'  # foreground for user entry labels
        self.frame_bg = 'grey40'  # background for data labels and frame
        self.frame_fg = 'grey90'
        self.passstub_fg = 'grey60'
        self.pass_fg = 'brown4'
        self.pass_bg = 'khaki2'

        # Variables used in window_setup(), in order of appearance:
        self.eff = tk.BooleanVar()
        self.numwords_label = tk.Label()
        self.numwords_entry = tk.Entry()
        self.numchars_label = tk.Label()
        self.numchars_entry = tk.Entry()
        self.generate_btn = tk.Button()
        self.quit_btn = tk.Button()
        self.result_frame = tk.Frame(self.master)
        self.length_label = tk.Label(self.result_frame)
        self.passphrase_label = tk.Label(self.result_frame)
        self.any_describe = tk.Label(self.result_frame)
        self.any_lc_describe = tk.Label(self.result_frame)
        self.select_describe = tk.Label(self.result_frame)
        self.length_any = tk.IntVar()
        self.length_lc = tk.IntVar()
        self.length_select = tk.IntVar()
        self.length_any_label = tk.Label(self.result_frame)
        self.length_lc_label = tk.Label(self.result_frame)
        self.length_select_label = tk.Label(self.result_frame)
        self.phrase_any = tk.StringVar()
        self.phrase_lc = tk.StringVar()
        self.phrase_select = tk.StringVar()
        self.phrase_any_display = tk.Entry(self.result_frame,
                                           textvariable=self.phrase_any)
        self.phrase_lc_display = tk.Entry(self.result_frame,
                                          textvariable=self.phrase_lc)
        self.phrase_sel_display = tk.Entry(self.result_frame,
                                           textvariable=self.phrase_select)
        self.pw_label = tk.Label(self.result_frame)
        self.pw_any_describe = tk.Label(self.result_frame)
        self.pw_select_describe = tk.Label(self.result_frame)
        self.pw_any = tk.StringVar()
        self.pw_select = tk.StringVar()
        self.pw_any_display = tk.Entry(self.result_frame,
                                       textvariable=self.pw_any,)
        self.pw_select_display = tk.Entry(self.result_frame,
                                          textvariable=self.pw_select)

        # Variables used in make_pass():
        self.word_list = []
        self.uniq_words = []
        self.trim_words = []
        self.allwords = None
        self.somewords = None
        self.effwords = None

        self.window_setup()

    def window_setup(self):
        """
        Layout the main window and assign initial values to labels.

        :return: A pretty interactive window.
        """
        self.master.configure(bg=self.master_bg)

        # creating a menu instance
        menu = tk.Menu(self.master)
        self.master.config(menu=menu)

        # Add pull-down menus
        file = tk.Menu(menu, tearoff=0)
        menu.add_cascade(label="File", menu=file)
        file.add_command(label="Quit", command=quitgui, accelerator="Ctrl+Q")

        help_menu = tk.Menu(menu, tearoff=0)
        menu.add_cascade(label="Help", menu=help_menu)
        help_menu.add_command(label="Word list info", command=word_info)
        help_menu.add_command(label="About", command=about)

        # Set up user entry and control:
        tk.Checkbutton(text='Use EFF word list ',
                       variable=self.eff,
                       fg=self.master_fg, bg=self.master_bg,
                       activebackground='grey80',
                       selectcolor=self.frame_bg
                       ).grid(column=2, row=0, pady=5, sticky=tk.W)
        self.numwords_label.config(text='Enter desired # words',
                                   fg=self.master_fg, bg=self.master_bg)
        self.numwords_entry.config(width=2)
        self.numwords_entry.insert(0, '5')
        self.numwords_entry.focus()
        self.numchars_label.config(text='Enter desired # characters',
                                   fg=self.master_fg, bg=self.master_bg)
        self.numchars_entry.config(width=3)
        self.numchars_entry.insert(0, 12)
        self.generate_btn.config(text='Generate!', command=self.make_pass)
        self.quit_btn.config(text='Quit', command=quitgui)

        self.numwords_label.grid(column=0, row=0, padx=5, pady=(5, 0),
                                 sticky=tk.E)
        self.numwords_entry.grid(column=1, row=0, pady=(5, 0), sticky=tk.W)
        self.numchars_label.grid(column=0, row=1, padx=5, pady=3, sticky=tk.E)
        self.numchars_entry.grid(column=1, row=1, sticky=tk.W)
        self.generate_btn.grid(  column=2, row=1, sticky=tk.W)
        self.quit_btn.grid(      column=3, row=1, sticky=tk.W)

        # Set up frame for results:
        self.result_frame.config(borderwidth=3, relief='sunken',
                                 background=self.frame_bg)
        self.result_frame.grid(column=0, row=2, columnspan=4, padx=5, pady=5)

        # Passphrase results section:
        # https://anzeljg.github.io/rin2/book2/2405/docs/tkinter/ttk-style-layer.html
        # This style statement for background of ttk.Labels does not work on MacOS
        # rstyle = ttk.Style()
        # rstyle.configure('TLabel', foreground=self.frame_fg, bg=self.frame_bg)
        self.length_label.config(    text='Length',
                                     fg=self.frame_fg, bg=self.frame_bg)
        self.passphrase_label.config(text='Passphrases',
                                     fg=self.frame_fg, bg=self.frame_bg)
        self.length_label.grid(    column=1, row=2, padx=5, sticky=tk.EW)
        self.passphrase_label.grid(column=2, row=2, padx=5, sticky=tk.W)

        self.any_describe.config(   text="Any words",
                                    fg=self.frame_fg, bg=self.frame_bg)
        self.any_lc_describe.config(text="Lower case, plus 3 symbols",
                                    fg=self.frame_fg, bg=self.frame_bg)
        self.select_describe.config(text="Words of 3 to 8 letters",
                                    fg=self.frame_fg, bg=self.frame_bg)
        self.any_describe.grid(   column=0, row=3, sticky=tk.E)
        self.any_lc_describe.grid(column=0, row=4, sticky=tk.E)
        self.select_describe.grid(column=0, row=5, sticky=tk.E)

        self.length_any.set(0)
        self.length_lc.set(0)
        self.length_select.set(0)
        self.length_any_label.config(   textvariable=self.length_any,
                                        width=3)
        self.length_lc_label.config(    textvariable=self.length_lc,
                                        width=3)
        self.length_select_label.config(textvariable=self.length_select,
                                        width=3)
        self.length_any_label.grid(   column=1, row=3)
        self.length_lc_label.grid(    column=1, row=4)
        self.length_select_label.grid(column=1, row=5)

        self.phrase_any.set(STUBRESULT)
        self.phrase_lc.set(STUBRESULT)
        self.phrase_select.set(STUBRESULT)
        self.phrase_any_display.config(width=50, font='TkFixedFont',
                                       fg=self.passstub_fg, bg=self.pass_bg)
        self.phrase_lc_display.config(width=50, font='TkFixedFont',
                                      fg=self.passstub_fg, bg=self.pass_bg)
        self.phrase_sel_display.config(width=50, font='TkFixedFont',
                                       fg=self.passstub_fg, bg=self.pass_bg)
        self.phrase_any_display.grid(column=2, row=3, columnspan=2,
                                     ipadx=5, padx=5, pady=3, sticky=tk.EW)
        self.phrase_lc_display.grid(column=2, row=4, columnspan=2,
                                    ipadx=5, padx=5, pady=3, sticky=tk.EW)
        self.phrase_sel_display.grid(column=2, row=5, columnspan=2,
                                     ipadx=5, padx=5, pady=3, sticky=tk.EW)

        # Password results section:
        self.pw_label.config(text='Passwords',
                             fg=self.frame_fg, bg=self.frame_bg)
        self.pw_label.grid(column=2, row=6, padx=5, sticky=tk.W)

        self.pw_any_describe.config(text="Any characters",
                                    fg=self.frame_fg, bg=self.frame_bg)
        self.pw_select_describe.config(text="More likely usable characters ",
                                       fg=self.frame_fg, bg=self.frame_bg)
        self.pw_any.set(STUBRESULT)
        self.pw_select.set(STUBRESULT)
        self.pw_any_display.config(width=50, font='TkFixedFont',
                                   fg=self.passstub_fg, bg=self.pass_bg)
        self.pw_select_display.config(width=50, font='TkFixedFont',
                                      fg=self.passstub_fg, bg=self.pass_bg)
        self.pw_any_describe.grid(   column=0, row=7,
                                     padx=5, sticky=tk.E)
        self.pw_select_describe.grid(column=0, row=8,
                                     padx=5, sticky=tk.E)
        self.pw_any_display.grid(    column=2, row=7, columnspan=2, ipadx=5,
                                     padx=5, pady=(6, 3), sticky=tk.EW)
        self.pw_select_display.grid( column=2, row=8, columnspan=2, ipadx=5,
                                     padx=5, pady=(3, 6), sticky=tk.EW)

    def make_pass(self):
        """Generate various forms of passphrases and passwords.
        """

        secure_random = random.SystemRandom()

        # sys_dictionary = Path('/usr/share/dict/words').read_text()
        word_list = SYS_DICTIONARY.split()
        # Need to remove words having the possessive form.
        uniq_words = [word for word in word_list if re.search(r"'s",word) is None]
        trim_words = [word for word in uniq_words if 8 >= len(word) >= 3]
        eff_list = EFF_DICTIONARY.split()
        eff_words = [word for word in eff_list if word.isalpha()]

        caps = ascii_uppercase
        string1 = ascii_letters + digits + punctuation
        string2 = ascii_letters + digits + SYMBOLS

        self.allwords = "".join(secure_random.choice(uniq_words) for
                           _ in range(int(self.numwords_entry.get())))
        self.somewords = "".join(secure_random.choice(trim_words) for
                            _ in range(int(self.numwords_entry.get())))
        self.effwords = "".join(secure_random.choice(eff_words) for
                           _ in range(int(self.numwords_entry.get())))
        addsymbol = "".join(secure_random.choice(SYMBOLS) for _ in range(1))
        addCap = "".join(secure_random.choice(caps) for _ in range(1))
        addnum = "".join(secure_random.choice(digits) for _ in range(1))

        if self.eff.get() is True:
            self.allwords = self.effwords
            self.somewords = self.effwords

        passphrase1 = self.allwords.lower() + addsymbol + addnum + addCap
        passphrase2 = self.somewords.lower() + addsymbol + addnum + addCap
        password1 = "".join(secure_random.choice(string1) for
                            _ in range(int(self.numchars_entry.get())))
        password2 = "".join(secure_random.choice(string2) for
                            _ in range(int(self.numchars_entry.get())))

        # display.config width will adjust width of results entry widgets to
        # the longest result string.
        self.phrase_any_display.config(width=len(passphrase1))
        self.pw_any_display.config(width=len(password1))
        self.pw_select_display.config(width=len(password2))

        self.phrase_any.set(self.allwords)
        self.phrase_lc.set(passphrase1)
        self.phrase_select.set(passphrase2)
        self.length_any.set(len(self.allwords))
        self.length_lc.set(len(passphrase1))
        self.length_select.set(len(passphrase2))
        self.pw_any.set(password1)
        self.pw_select.set(password2)
        # Change font colors of the results from self.passstub_fg
        self.phrase_any_display.config(fg=self.pass_fg)
        self.phrase_lc_display.config(fg=self.pass_fg)
        self.phrase_sel_display.config(fg=self.pass_fg)
        self.pw_any_display.config(fg=self.pass_fg)
        self.pw_select_display.config(fg=self.pass_fg)


def about() -> None:
    """
    Basic information for count-tasks; called from GUI Help menu.

    :return: Information window.
    """
    # msg separators use em dashes.
    boilerplate = ("""
pygPassphrase privately generates passphrases and passwords.
Download the most recent version from: 
https://github.com/csecht/general_utilities

————————————————————————————————————————————————————————————————————
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.\n
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.\n
You should have received a copy of the GNU General Public License
along with this program. If not, see https://www.gnu.org/licenses/
————————————————————————————————————————————————————————————————————\n
            Author:     cecht
            Copyright:  Copyright (C) 2021 C. Echt
            Development Status: 4 - Beta
            Version:    """)

    num_lines = boilerplate.count('\n')
    aboutwin = tk.Toplevel()
    # aboutwin.minsize(570, 460)
    aboutwin.title('About count-tasks')
    colour = ['SkyBlue4', 'DarkSeaGreen4', 'DarkGoldenrod4', 'DarkOrange4',
              'grey40', 'blue4', 'navy', 'DeepSkyBlue4', 'dark slate grey',
              'dark olive green', 'grey2', 'grey25', 'DodgerBlue4',
              'DarkOrchid4']
    bkg = random.choice(colour)
    abouttxt = tk.Text(aboutwin, width=72, height=num_lines + 2,
                       background=bkg, foreground='grey98',
                       relief='groove', borderwidth=5, padx=5)
    abouttxt.insert('1.0', boilerplate + PROGRAM_VER)
    # Center text preceding the Author, etc. details.
    abouttxt.tag_add('text1', '1.0', float(num_lines - 5))
    abouttxt.tag_configure('text1', justify='center')
    abouttxt.pack()


def word_info() -> None:
    """Provide information about number of words used to create passphrases
    """
    # This duplicates statements from make_pass(). So include as class method?
    word_list = SYS_DICTIONARY.split()
    uniq_words = [word for word in word_list if re.search(r"'s", word) is None]
    trim_words = [word for word in uniq_words if 8 >= len(word) >= 3]
    eff_list = EFF_DICTIONARY.split()
    eff_words = [word for word in eff_list if word.isalpha()]

    info = (f'In the system dictionary used to create passphrases:\n'
            f"   There are {len(word_list)} words in the entire dictionary.\n"
            f"   There are {len(uniq_words)} unique words (excludes "
            "possessive forms of nouns (English dictionary)\n"
            f"   There are {len(trim_words)} unique words of 3 to 8 letters.\n"
            "Passphrases may include proper names found in the dictionary.\n"
            "The extra symbols added to passphrases and those more likely "
            f"usable in passwords are: {SYMBOLS}\n\n"
            f"The word list from Electronic Frontier Foundation (EFF), \n"
            "https://www.eff.org/files/2016/07/18/eff_large_wordlist.txt, \n"
            f"contains 7776 selected words, but only {len(eff_words)} are used here.\n"
            "For more information on EFF's diceware word list selection, see:\n"
            'https://www.eff.org/deeplinks/2016/07/new-wordlists-random-passphrases'
            )

    infowin = tk.Toplevel()
    # infowin.minsize(750, 250)
    infowin.title('Information about words used')
    infotxt = tk.Text(infowin, width=100, height=15,
                      background='SkyBlue4', foreground='grey98',
                      relief='groove', borderwidth=5, padx=5)
    infotxt.insert('1.0', info)
    # Center text preceding the Author, etc. details.
    # infotxt.tag_add('text1', '1.0', float(num_lines - 5))
    # infotxt.tag_configure('text1', justify='center')
    infotxt.pack()


def quitgui() -> None:
    """Safe and informative exit from the program.
    """
    print(f'\n  *** User has quit {__file__}. Exiting...\n')
    root.destroy()


if __name__ == "__main__":
    os.chdir(os.path.dirname(os.path.realpath(__file__)))
    root = tk.Tk()
    root.title("Passphrase Generator")
    # root.resizable(False, False)
    Generator(root)
    root.mainloop()
