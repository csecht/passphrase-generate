#!/usr/bin/env python3

"""
Inspired by and based on code from @codehub.py via Instagram.
Not usable on Windows because of no way(?) to read the Dictionary.
"""
import os
import random
import re
import sys
from string import digits, punctuation, ascii_letters, ascii_uppercase
from pathlib import Path

try:
    import tkinter as tk
    from tkinter import messagebox
    import tkinter.ttk as ttk
except (ImportError, ModuleNotFoundError) as error:
    print('GUI requires tkinter, which is included with Python 3.7 and higher'
          '\nInstall 3.7+ or re-install Python and include Tk/Tcl.'
          f'\nSee also: https://tkdocs.com/tutorial/install.html \n{error}')

PROGRAM_VER = '0.2.1'
STUBRESULT = 'Result can be copied and pasted'
SYMBOLS = "~!@#$%^&*_-"
MY_OS = sys.platform[:3]
# MY_OS = 'win' # TESTING
SYSWORDS_PATH = Path('/usr/share/dict/words')
EFFWORDS_PATH = Path('eff_large_wordlist.txt')


class Generator:
    """
    A GUI window for user to specify length of passphrases and passwords.
    """
    def __init__(self, master):
        """Window layout and default values are set up here.
        """
        self.master = master
        self.master.bind("<Escape>", lambda q: quit_gui())
        self.master.bind("<Control-q>", lambda q: quit_gui())
        self.master.bind("<Control-g>", lambda q: self.make_pass())

        # main window background color, also used for some labels.
        self.master_bg = 'SkyBlue4'
        self.master_fg = 'LightCyan2'  # foreground for user entry labels
        self.frame_bg = 'grey40'  # background for data labels and frame
        self.frame_fg = 'grey90'
        self.passstub_fg = 'grey60'
        self.pass_fg = 'brown4'
        self.pass_bg = 'khaki2'

        # Variables used in setup_window(), in order of appearance:
        #  Don't make an EFF checkbutton in Windows b/c EFF words are default.
        if MY_OS in 'lin, dar':
            self.eff = tk.BooleanVar()
            self.eff_chk = tk.Checkbutton()
        self.numwords_label = tk.Label()
        self.numwords_entry = tk.Entry()
        self.numchars_label = tk.Label()
        self.numchars_entry = tk.Entry()

        # There are problems of tk.Button text showing up on MacOS, so ttk
        self.generate_btn = ttk.Button()
        self.quit_btn = ttk.Button()

        self.result_frame = tk.Frame(self.master)

        self.length_label = tk.Label(self.result_frame)
        self.passphrase_label = tk.Label(self.result_frame)
        self.any_describe = tk.Label(self.result_frame)
        self.any_lc_describe = tk.Label(self.result_frame)
        self.select_describe = tk.Label(self.result_frame)
        self.length_any = tk.IntVar()
        self.length_lc = tk.IntVar()
        self.length_select = tk.IntVar()
        self.length_any_label = tk.Label(self.result_frame)
        self.length_lc_label = tk.Label(self.result_frame)
        self.length_select_label = tk.Label(self.result_frame)
        self.phrase_any = tk.StringVar()
        self.phrase_lc = tk.StringVar()
        self.phrase_select = tk.StringVar()
        self.phrase_any_display = tk.Entry(self.result_frame,
                                           textvariable=self.phrase_any)
        self.phrase_lc_display = tk.Entry(self.result_frame,
                                          textvariable=self.phrase_lc)
        self.phrase_sel_display = tk.Entry(self.result_frame,
                                           textvariable=self.phrase_select)
        self.pw_label = tk.Label(self.result_frame)
        self.pw_any_describe = tk.Label(self.result_frame)
        self.pw_select_describe = tk.Label(self.result_frame)
        self.pw_any = tk.StringVar()
        self.pw_select = tk.StringVar()
        self.pw_any_display = tk.Entry(self.result_frame,
                                       textvariable=self.pw_any,)
        self.pw_select_display = tk.Entry(self.result_frame,
                                          textvariable=self.pw_select)

        # Variables used in get_words():
        self.use_effwords = True
        self.system_words = 'None'
        self.eff_wordlist = 'None'
        self.eff_list = ['None']
        self.system_list = ['None']

        self.setup_window()

    def setup_window(self) -> None:
        """
        Layout the main window and assign initial values to labels.

        :return: A pretty interactive window.
        """
        self.master.configure(bg=self.master_bg)

        # creating a menu instance
        menu = tk.Menu(self.master)
        self.master.config(menu=menu)

        # Add pull-down menus
        file = tk.Menu(menu, tearoff=0)
        menu.add_cascade(label="File", menu=file)
        file.add_command(label="Generate", command=self.make_pass,
                         accelerator="Ctrl+G")
        file.add_command(label="Quit", command=quit_gui, accelerator="Ctrl+Q")

        help_menu = tk.Menu(menu, tearoff=0)
        menu.add_cascade(label="Help", menu=help_menu)
        help_menu.add_command(label="What are passphrases?",
                              command=self.explain)
        help_menu.add_command(label="About", command=about)

        # Set up user entry and control:
        if MY_OS in 'lin, dar':
            self.eff_chk.config(text='Use EFF word list ',
                                variable=self.eff,
                                fg=self.master_fg, bg=self.master_bg,
                                activebackground='grey80',
                                selectcolor=self.frame_bg)
            self.eff_chk.grid(column=2, row=0, pady=5, sticky=tk.W)
        if self.use_effwords is False:
            self.eff_chk.config(state='disabled')

        self.numwords_label.config(text='Enter # words for passphrase',
                                   fg=self.master_fg, bg=self.master_bg)
        self.numwords_entry.config(width=2)
        self.numwords_entry.insert(0, '5')
        self.numwords_entry.focus()
        self.numchars_label.config(text='Enter # characters for password',
                                   fg=self.master_fg, bg=self.master_bg)
        self.numchars_entry.config(width=3)
        self.numchars_entry.insert(0, 0)

        style = ttk.Style()
        style.map("G.TButton",
                  foreground=[('active', 'blue')],
                  background=[('pressed', self.frame_bg),
                              ('active', self.master_fg)])
        style.map("Q.TButton",
                  # foreground=[('active', 'black')],
                  background=[('pressed', self.frame_bg),
                              ('active', 'orange')])
        self.generate_btn.configure(style="G.TButton", text='Generate!',
                                    command=self.make_pass)
        self.quit_btn.configure(style="Q.TButton", text='Quit',
                                command=quit_gui)

        # self.eff_chk.grid(column=2, row=0, pady=5, sticky=tk.W)
        self.numwords_label.grid(column=0, row=0, padx=5, pady=(5, 0),
                                 sticky=tk.E)
        self.numwords_entry.grid(column=1, row=0, pady=(5, 0), sticky=tk.W)
        self.numchars_label.grid(column=0, row=1, padx=5, pady=3, sticky=tk.E)
        self.numchars_entry.grid(column=1, row=1, sticky=tk.W)
        self.generate_btn.grid(  column=2, row=1, sticky=tk.W)
        self.quit_btn.grid(      column=3, row=1, sticky=tk.W)

        # Set up frame for results:
        self.result_frame.config(borderwidth=3, relief='sunken',
                                 background=self.frame_bg)
        self.result_frame.grid(column=0, row=2, columnspan=4, padx=5, pady=5)

        # Passphrase results section:
        # https://anzeljg.github.io/rin2/book2/2405/docs/tkinter/ttk-style-layer.html
        # This style statement for background of ttk.Labels does not work on MacOS
        # rstyle = ttk.Style()
        # rstyle.configure('TLabel', foreground=self.frame_fg, bg=self.frame_bg)
        self.length_label.config(    text='Length',
                                     fg=self.frame_fg, bg=self.frame_bg)
        self.passphrase_label.config(text='Passphrases',
                                     fg=self.frame_fg, bg=self.frame_bg)
        self.length_label.grid(    column=1, row=2, padx=5, sticky=tk.EW)
        self.passphrase_label.grid(column=2, row=2, padx=5, sticky=tk.W)

        self.any_describe.config(   text="Any words",
                                    fg=self.frame_fg, bg=self.frame_bg)
        self.any_lc_describe.config(text="Lower case, plus 3 symbols",
                                    fg=self.frame_fg, bg=self.frame_bg)
        self.select_describe.config(text="Words of 3 to 8 letters",
                                    fg=self.frame_fg, bg=self.frame_bg)
        self.any_describe.grid(   column=0, row=3, sticky=tk.E)
        self.any_lc_describe.grid(column=0, row=4, sticky=tk.E)
        self.select_describe.grid(column=0, row=5, sticky=tk.E)

        self.length_any.set(0)
        self.length_lc.set(0)
        self.length_select.set(0)
        self.length_any_label.config(   textvariable=self.length_any,
                                        width=3)
        self.length_lc_label.config(    textvariable=self.length_lc,
                                        width=3)
        self.length_select_label.config(textvariable=self.length_select,
                                        width=3)
        self.length_any_label.grid(   column=1, row=3)
        self.length_lc_label.grid(    column=1, row=4)
        self.length_select_label.grid(column=1, row=5)

        self.phrase_any.set(STUBRESULT)
        self.phrase_lc.set(STUBRESULT)
        self.phrase_select.set(STUBRESULT)
        self.phrase_any_display.config(width=50, font='TkFixedFont',
                                       fg=self.passstub_fg, bg=self.pass_bg)
        self.phrase_lc_display.config(width=50, font='TkFixedFont',
                                      fg=self.passstub_fg, bg=self.pass_bg)
        self.phrase_sel_display.config(width=50, font='TkFixedFont',
                                       fg=self.passstub_fg, bg=self.pass_bg)
        self.phrase_any_display.grid(column=2, row=3, columnspan=2,
                                     ipadx=5, padx=5, pady=3, sticky=tk.EW)
        self.phrase_lc_display.grid(column=2, row=4, columnspan=2,
                                    ipadx=5, padx=5, pady=3, sticky=tk.EW)
        self.phrase_sel_display.grid(column=2, row=5, columnspan=2,
                                     ipadx=5, padx=5, pady=3, sticky=tk.EW)

        # Password results section:
        self.pw_label.config(text='Passwords',
                             fg=self.frame_fg, bg=self.frame_bg)
        self.pw_label.grid(column=2, row=6, padx=5, sticky=tk.W)

        self.pw_any_describe.config(text="Any characters",
                                    fg=self.frame_fg, bg=self.frame_bg)
        self.pw_select_describe.config(text="More likely usable characters ",
                                       fg=self.frame_fg, bg=self.frame_bg)
        self.pw_any.set(STUBRESULT)
        self.pw_select.set(STUBRESULT)
        self.pw_any_display.config(width=50, font='TkFixedFont',
                                   fg=self.passstub_fg, bg=self.pass_bg)
        self.pw_select_display.config(width=50, font='TkFixedFont',
                                      fg=self.passstub_fg, bg=self.pass_bg)
        self.pw_any_describe.grid(   column=0, row=7,
                                     padx=5, sticky=tk.E)
        self.pw_select_describe.grid(column=0, row=8,
                                     padx=5, sticky=tk.E)
        self.pw_any_display.grid(    column=2, row=7, columnspan=2, ipadx=5,
                                     padx=5, pady=(6, 3), sticky=tk.EW)
        self.pw_select_display.grid( column=2, row=8, columnspan=2, ipadx=5,
                                     padx=5, pady=(3, 6), sticky=tk.EW)

    def get_words(self) -> None:
        """
        Check which word files are available; populate lists for make_pass().
        """
        fnf_msg = (
            '\n*** Cannot locate either the system dictionary or EFF wordlist\n'
            'At a minimum, the file eff_large_wordlist.txt should be in '
            'the working directory.\nThat file can is included with:\n'
            'https://github.com/csecht/general_utilities\n'
            'Exiting now...')
        if MY_OS in 'lin, dar':
            if Path.is_file(SYSWORDS_PATH) is False and \
                    Path.is_file(EFFWORDS_PATH) is False:
                print(fnf_msg)
                sys.exit(1)
        elif MY_OS == 'win' and Path.is_file(EFFWORDS_PATH) is False:
            print(fnf_msg)
            sys.exit(1)

        if MY_OS == 'win':
            self.system_words = 'Null'
            self.eff_wordlist = Path(EFFWORDS_PATH).read_text()

        if MY_OS in 'lin, dar':
            if Path.is_file(SYSWORDS_PATH):
                self.system_words = Path(SYSWORDS_PATH).read_text()
            elif Path.is_file(SYSWORDS_PATH) is False:
                notice = ('*** NOTICE: The system dictionary cannot be found.\n'
                          'Using EFF word list ... ***')
                self.system_words = 'Null'
                self.eff_chk.config(state='disabled')
                print(notice)
                messagebox.showinfo(title='File not found',
                                    detail=notice)
            if Path.is_file(EFFWORDS_PATH):
                self.eff_wordlist = Path(EFFWORDS_PATH).read_text()
            elif Path.is_file(EFFWORDS_PATH) is False:
                self.use_effwords = False  # Used in window_setup().
                notice = (
                    '*** EFF large wordlist cannot be found.\n'
                    'That file is included with:\n'
                    'https://github.com/csecht/general_utilities\n'
                    'Using system dictionary... ***\n'
                )
                self.eff_chk.config(state='disabled')
                print(notice)
                messagebox.showinfo(title='File not found',
                                    detail=notice)
        self.system_list = self.system_words.split()
        self.eff_list = self.eff_wordlist.split()

    def make_pass(self) -> None:
        """Generate various forms of passphrases and passwords.
        """

        secure_random = random.SystemRandom()

        # Need to remove words having the possessive form.
        uniq_words = \
            [word for word in self.system_list if re.search(r"'s", word) is None]
        trim_words = [word for word in uniq_words if 8 >= len(word) >= 3]
        eff_words = [word for word in self.eff_list if word.isalpha()]

        caps = ascii_uppercase
        string1 = ascii_letters + digits + punctuation
        string2 = ascii_letters + digits + SYMBOLS

        allwords = "".join(secure_random.choice(uniq_words) for
                           _ in range(int(self.numwords_entry.get())))
        somewords = "".join(secure_random.choice(trim_words) for
                            _ in range(int(self.numwords_entry.get())))
        effwords = "".join(secure_random.choice(eff_words) for
                           _ in range(int(self.numwords_entry.get())))
        addsymbol = "".join(secure_random.choice(SYMBOLS) for _ in range(1))
        addcaps = "".join(secure_random.choice(caps) for _ in range(1))
        addnum = "".join(secure_random.choice(digits) for _ in range(1))

        # 1st condition evaluates eff checkbutton on, 2nd if no sys dict found.
        # 3rd, EFF is forced in linux, Mac, so disable eff checkbutton.
        # There is probably a less confusing way to work these conditions.
        if MY_OS in 'lin, dar' and self.eff.get() is True:
            allwords = effwords
            somewords = effwords
        elif MY_OS == 'win' or self.system_words == 'Null':
            allwords = effwords
            somewords = effwords
            if MY_OS in 'lin, dar':
                self.eff_chk.config(state='disabled')

        passphrase1 = allwords.lower() + addsymbol + addnum + addcaps
        passphrase2 = somewords.lower() + addsymbol + addnum + addcaps
        password1 = "".join(secure_random.choice(string1) for
                            _ in range(int(self.numchars_entry.get())))
        password2 = "".join(secure_random.choice(string2) for
                            _ in range(int(self.numchars_entry.get())))

        # display.config width will adjust width of results entry widgets to
        # the longest result string.
        self.phrase_any_display.config(width=len(passphrase1))
        self.pw_any_display.config(width=len(password1))
        self.pw_select_display.config(width=len(password2))
        # Need to lower font size of long pass* length in attempt to keep
        # window on screen, then reset to default font size when pass*
        # length is shortened. On Mac Retina monitors, fonts can be very small.
        if len(passphrase1) > 75:
            self.phrase_any_display.config(font=('TkFixedFont', 8))
            self.phrase_lc_display.config(font=('TkFixedFont', 8))
            self.phrase_sel_display.config(font=('TkFixedFont', 8))
        elif len(passphrase1) <= 75:
            self.phrase_any_display.config(font='TkFixedFont')
            self.phrase_lc_display.config(font='TkFixedFont')
            self.phrase_sel_display.config(font='TkFixedFont')
        if len(password1) > 75:
            self.pw_any_display.config(font=('TkFixedFont', 8))
            self.pw_select_display.config(font=('TkFixedFont', 8))
        elif len(password1) <= 75:
            self.pw_any_display.config(font='TkFixedFont')
            self.pw_select_display.config(font='TkFixedFont')

        self.phrase_any.set(allwords)
        self.phrase_lc.set(passphrase1)
        self.phrase_select.set(passphrase2)
        self.length_any.set(len(allwords))
        self.length_lc.set(len(passphrase1))
        self.length_select.set(len(passphrase2))
        self.pw_any.set(password1)
        self.pw_select.set(password2)
        # Change font colors of results from the initial self.passstub_fg.
        self.phrase_any_display.config(fg=self.pass_fg)
        self.phrase_lc_display.config(fg=self.pass_fg)
        self.phrase_sel_display.config(fg=self.pass_fg)
        self.pw_any_display.config(fg=self.pass_fg)
        self.pw_select_display.config(fg=self.pass_fg)

    def explain(self) -> None:
        """Provide information about number of words used to create passphrases
        """
        # This duplicates statements from make_pass().  Would require
        # separate method for these variables to consolidate?...
        word_list = self.system_words.split()
        uniq_words = [word for word in word_list if
                      re.search(r"'s", word) is None]
        trim_words = [word for word in uniq_words if 8 >= len(word) >= 3]
        eff_list = self.eff_wordlist.split()
        eff_words = [word for word in eff_list if word.isalpha()]

        info = (
            'A passphrase is a random string of words that can be more '
            'secure and \n'
            'easier to remember than a shorter or complicated password.\n'
            "For more information on passphrases, see EFF's discussion, "
            "for example,\n"
            'of diceware and wordlist selection at:\n'
            'https://www.eff.org/deeplinks/2016/07/new-wordlists-random'
            '-passphrases\n\n'
            'This program has an option to use the EFF long wordlist, however,'
            ' Windows\nsystems will use only that list.\n\n'
            f'In the (non-Windows) system dictionary used for passphrases:\n'
            f"    There are {len(word_list)} words in that dictionary.\n"
            f"    There are {len(uniq_words)} unique words (excluding "
            "possessive forms of nouns.\n"
            f"    There are {len(trim_words)} unique words of 3 to 8 letters.\n"
            "Passphrases may include proper names and diacritics found in the "
            "dictionary.\n"
            "The symbols added to passphrases and those that are more likely\n"
            f"usable in passwords are: {SYMBOLS}\n\n"
            'The word list from Electronic Frontier Foundation (EFF),\n'
            'https://www.eff.org/files/2016/07/18/eff_large_wordlist.txt, '
            'does not contain \nproper names or diacritics and its words are '
            'generally shorter and easier to spell.\n'
            'While that official list contains 7776 selected words, only '
            f'{len(eff_words)} are used here by\nexcluding four hyphenated '
            f'words.')

        infowin = tk.Toplevel()
        # infowin.minsize(750, 250)
        infowin.title('A little about passphrases')
        num_lines = info.count('\n')
        infotxt = tk.Text(infowin, width=85, height=num_lines + 2,
                          background='SkyBlue4', foreground='grey98',
                          relief='groove', borderwidth=5, padx=5)
        infotxt.insert('1.0', info)
        # Center text preceding the Author, etc. details.
        # infotxt.tag_add('text1', '1.0', float(num_lines - 5))
        # infotxt.tag_configure('text1', justify='center')
        infotxt.pack()


def about() -> None:
    """
    Basic information for count-tasks; called from GUI Help menu.

    :return: Information window.
    """
    # msg separators use em dashes.
    boilerplate = ("""
pygPassphrase privately generates passphrases and passwords.
Download the most recent version from: 
https://github.com/csecht/general_utilities

————————————————————————————————————————————————————————————————————
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.\n
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.\n
You should have received a copy of the GNU General Public License
along with this program. If not, see https://www.gnu.org/licenses/
————————————————————————————————————————————————————————————————————\n
            Author:     cecht
            Copyright:  Copyright (C) 2021 C. Echt
            Development Status: 4 - Beta
            Version:    """)

    num_lines = boilerplate.count('\n')
    aboutwin = tk.Toplevel()
    # aboutwin.minsize(570, 460)
    aboutwin.title('About count-tasks')
    colour = ['SkyBlue4', 'DarkSeaGreen4', 'DarkGoldenrod4', 'DarkOrange4',
              'grey40', 'blue4', 'navy', 'DeepSkyBlue4', 'dark slate grey',
              'dark olive green', 'grey2', 'grey25', 'DodgerBlue4',
              'DarkOrchid4']
    bkg = random.choice(colour)
    abouttxt = tk.Text(aboutwin, width=72, height=num_lines + 2,
                       background=bkg, foreground='grey98',
                       relief='groove', borderwidth=5, padx=5)
    abouttxt.insert('1.0', boilerplate + PROGRAM_VER)
    # Center text preceding the Author, etc. details.
    abouttxt.tag_add('text1', '1.0', float(num_lines - 5))
    abouttxt.tag_configure('text1', justify='center')
    abouttxt.pack()


def quit_gui() -> None:
    """Safe and informative exit from the program.
    """
    print(f'\n  *** User has quit {__file__}. Exiting...\n')
    root.destroy()
    sys.exit(0)


if __name__ == "__main__":
    os.chdir(os.path.dirname(os.path.realpath(__file__)))
    root = tk.Tk()
    root.title("Passphrase Generator")
    # root.minsize(1000, 300)
    Generator(root).get_words()
    root.mainloop()
